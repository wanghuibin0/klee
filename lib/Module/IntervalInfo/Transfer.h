#ifndef TRANSFER_H
#define TRANSFER_H

#include "MyDebug.h"

#include "Env.h"
#include "EnvMap.h"
#include "EqRels.h"
#include "Transfer.h"
#include "klee/Support/Debug.h"
#include "llvm/Analysis/LoopInfo.h"
#include "llvm/IR/CFG.h"
#include "llvm/IR/Constants.h"
#include "llvm/IR/Instruction.h"
#include "llvm/IR/Instructions.h"
#include "llvm/Support/Casting.h"
#include "llvm/Support/raw_ostream.h"

namespace klee {

class Transfer {
  llvm::BasicBlock *bb;
  EnvMap &gEnvMap;
  llvm::LoopInfo &LI;
  std::map<llvm::BasicBlock *, Env> succEnvs; // envs formed by conditionals

  Env internalEnv;

public:
  Transfer(llvm::BasicBlock *bb, EnvMap &envMap, llvm::LoopInfo &LI)
      : bb(bb), gEnvMap(envMap), LI(LI) {
    if (this->bb != &this->bb->getParent()->getEntryBlock()) {
      collectEnvIn();
    } else {
      internalEnv = gEnvMap.getEnv(nullptr, bb);
    }
  }

  void execute() {
    MY_KLEE_DEBUG(internalEnv.dump(llvm::outs()));
    for (auto &&i : *bb) {
      executeInstruction(&i);
    }
    updateEnvOut();
  }

private:
  /// this should be called before executing the block. (in constructor)
  /// worth noting that this is not appliable to entry block.
  void collectEnvIn() {
    MY_KLEE_DEBUG(llvm::outs() << "collect env comming in bb: " << bb << "\n");
    if (LI.isLoopHeader(bb)) {
      collectEnvForLoopheader();
    } else {
      for (auto &&b : predecessors(bb)) {
        auto &env = gEnvMap.getEnv(b, bb);
        internalEnv = internalEnv | env;
      }
    }
  }

  // do widening for loop header
  void collectEnvForLoopheader() {
    // resolve which edge is back edge
    llvm::BasicBlock *latchBB = nullptr;
    llvm::BasicBlock *preHeader = nullptr;
    unsigned numPreds = 0;
    for (auto &&b : predecessors(bb)) {
      ++numPreds;
      if (isLoopBackEdge(b, bb)) {
        latchBB = b;
      } else {
        preHeader = b;
      }
    }
    assert(numPreds == 2 &&
           "the number of predecessors of loopheader is not 2");
    assert(latchBB != nullptr && "there must be a back edge");

    Env &latchEnv = gEnvMap.getEnv(latchBB, bb);
    Env &preEnv = gEnvMap.getEnv(preHeader, bb);
    if (latchEnv.empty()) {
      internalEnv = preEnv;
    } else {
      internalEnv = preEnv || latchEnv; // widening
    }
  }

  /// this should be called after executing the block.
  void updateEnvOut() {
    MY_KLEE_DEBUG(llvm::outs() << "updating env out of bb: " << bb << "\n");
    assert(succEnvs.size() == 0 || succEnvs.size() == 2);
    if (succEnvs.size() == 0) {
      // only has one successor
      llvm::BasicBlock *b = bb->getUniqueSuccessor();
      gEnvMap.mergeAndUpdate(bb, b, internalEnv);
    } else {
      // has two successors
      updateEnvOutBr();
    }
  }

  /// update env for two successive blocks
  void updateEnvOutBr() {
    for (auto &&sit : succEnvs) {
      llvm::BasicBlock *b = sit.first;
      Env envBr = mergeConditionalEnv(sit.second);

      gEnvMap.update(bb, b, envBr);
    }
  }

  bool isLoopBackEdge(llvm::BasicBlock *from, llvm::BasicBlock *to) {
    llvm::Loop *loop = LI.getLoopFor(from);
    return loop && loop->isLoopLatch(from) && LI.isLoopHeader(to);
  }

  /// merge the env generated by conditionals, return the merged env.
  Env mergeConditionalEnv(const Env &condEnv) {
    Env res{internalEnv};
    for (auto &&it : internalEnv) {
      llvm::Value *v = it.first;
      Interval i = it.second;
      if (condEnv.hasValue(v)) {
        Interval condI = condEnv.lookup(v);
        if (condI.isBot()) {
          res.clear();
          break;
        }
        res.set(v, i & condI);
      }
    }
    return res;
  }

  /// change env according to the instruction
  void executeInstruction(llvm::Instruction *inst) {
    MY_KLEE_DEBUG(llvm::outs() << "execute instruction:\n");
    MY_KLEE_DEBUG(llvm::outs() << *inst << "\n");
    if (llvm::isa<llvm::StoreInst>(inst)) {
      llvm::StoreInst *i = llvm::cast<llvm::StoreInst>(inst);
      llvm::Value *v = i->getValueOperand();
      llvm::Value *p = i->getPointerOperand();
      if (auto *c = llvm::dyn_cast<llvm::ConstantInt>(v)) {
        auto value = c->getSExtValue();
        Interval i(value, value);
        internalEnv.set(p, i);
      } else {
        assert(internalEnv.hasValue(v));
        internalEnv.set(p, internalEnv.lookup(v));
      }
    } else if (llvm::isa<llvm::LoadInst>(inst)) {
      llvm::LoadInst *i = llvm::cast<llvm::LoadInst>(inst);
      llvm::Value *p = i->getPointerOperand();
      assert(internalEnv.hasValue(p));
      auto v = internalEnv.lookup(p);
      internalEnv.set(inst, v);
    } else if (llvm::isa<llvm::BitCastInst>(inst)) {
      llvm::BitCastInst *i = llvm::cast<llvm::BitCastInst>(inst);
      llvm::Value *src = i->getOperand(0);
      assert(internalEnv.hasValue(src));
      Interval iv = internalEnv.lookup(src);
      internalEnv.set(inst, iv);
    } else if (llvm::isa<llvm::BinaryOperator>(inst)) {
      executeBinaryOp(llvm::cast<llvm::BinaryOperator>(inst));
    } else if (llvm::isa<llvm::CmpInst>(inst)) {
      executeCmpInst(llvm::cast<llvm::CmpInst>(inst));
    } else if (llvm::isa<llvm::CallInst>(inst)) {
      executeCallInst(llvm::cast<llvm::CallInst>(inst));
    } else {
      executeOtherInst(inst);
    }
  }

  void executeBinaryOp(llvm::BinaryOperator *binst) {
    llvm::Value *op1 = binst->getOperand(0);
    llvm::ConstantInt *c1 = llvm::dyn_cast<llvm::ConstantInt>(op1);
    llvm::Value *op2 = binst->getOperand(1);
    llvm::ConstantInt *c2 = llvm::dyn_cast<llvm::ConstantInt>(op2);

    auto opcode = binst->getOpcode();
    Interval i;
    if (c1 && c2) {
      auto v1 = c1->getSExtValue();
      auto v2 = c2->getSExtValue();
      i = apply(opcode, Interval(v1, v1), Interval(v2, v2));
    } else if (c1 && !c2) {
      auto v1 = c1->getSExtValue();
      i = apply(opcode, Interval(v1, v1), internalEnv.lookup(op2));
    } else if (!c1 && c2) {
      auto v2 = c2->getSExtValue();
      i = apply(opcode, internalEnv.lookup(op1), Interval(v2, v2));
    } else {
      i = apply(opcode, internalEnv.lookup(op1), internalEnv.lookup(op2));
    }
    internalEnv.set(binst, i);
  }

  /// apply add/sub/mul/div directly on two intervals
  Interval apply(unsigned opcode, Interval i1, Interval i2) {
    Interval ret;
    switch (opcode) {
    case llvm::Instruction::Add:
      ret = i1 + i2;
      break;
    case llvm::Instruction::Sub:
      ret = i1 - i2;
      break;
    case llvm::Instruction::Mul:
      ret = i1 * i2;
      break;
    case llvm::Instruction::SDiv:
      ret = i1 / i2;
      break;
    }
    return ret;
  }

  void executeCmpInst(llvm::CmpInst *binst) {
    llvm::Value *op1 = binst->getOperand(0);
    llvm::ConstantInt *c1 = llvm::dyn_cast<llvm::ConstantInt>(op1);
    llvm::Value *op2 = binst->getOperand(1);
    llvm::ConstantInt *c2 = llvm::dyn_cast<llvm::ConstantInt>(op2);

    llvm::TerminatorInst *ti = bb->getTerminator();
    if (!llvm::isa<llvm::BranchInst>(ti))
      return;
    if (ti->getNumOperands() != 3)
      return;

    llvm::BasicBlock *bbf = llvm::cast<llvm::BasicBlock>(ti->getOperand(1));
    llvm::BasicBlock *bbt = llvm::cast<llvm::BasicBlock>(ti->getOperand(2));

    EqRels eqrels;
    for (auto &&i : *bb) {
      if (llvm::isa<llvm::LoadInst>(&i)) {
        llvm::Value *ptr = llvm::cast<llvm::LoadInst>(&i)->getPointerOperand();
        eqrels.processLoad(ptr, &i);
      } else if (llvm::isa<llvm::StoreInst>(&i)) {
        llvm::Value *ptr = llvm::cast<llvm::StoreInst>(&i)->getPointerOperand();
        eqrels.processStore(ptr, &i);
      }
    }

    llvm::CmpInst::Predicate p = binst->getPredicate();

    if (c1 && !c2) {
      applyCmpValReg(p, c1, op2, bbt, bbf, eqrels);
    } else if (!c1 && c2) {
      applyCmpRegVal(p, op1, c2, bbt, bbf, eqrels);
    } else if (!c1 && !c2) {
      applyCmpRegReg(p, op1, op2, bbt, bbf, eqrels);
    } else {
      assert(0);
    }
  }

  void applyCmpValReg(llvm::CmpInst::Predicate p, llvm::ConstantInt *c1,
                      llvm::Value *op2, llvm::BasicBlock *bbt,
                      llvm::BasicBlock *bbf, EqRels &eqrels) {
    switch (p) {
    case llvm::CmpInst::Predicate::ICMP_SLT:
      applyCmpRegVal(llvm::CmpInst::Predicate::ICMP_SGT, op2, c1, bbt, bbf,
                     eqrels);
      break;
    case llvm::CmpInst::Predicate::ICMP_SLE:
      applyCmpRegVal(llvm::CmpInst::Predicate::ICMP_SGE, op2, c1, bbt, bbf,
                     eqrels);
      break;
    case llvm::CmpInst::Predicate::ICMP_SGT:
      applyCmpRegVal(llvm::CmpInst::Predicate::ICMP_SLT, op2, c1, bbt, bbf,
                     eqrels);
      break;
    case llvm::CmpInst::Predicate::ICMP_SGE:
      applyCmpRegVal(llvm::CmpInst::Predicate::ICMP_SLE, op2, c1, bbt, bbf,
                     eqrels);
      break;
    case llvm::CmpInst::Predicate::ICMP_EQ:
      applyCmpRegVal(llvm::CmpInst::Predicate::ICMP_EQ, op2, c1, bbt, bbf,
                     eqrels);
      break;
    case llvm::CmpInst::Predicate::ICMP_NE:
      applyCmpRegVal(llvm::CmpInst::Predicate::ICMP_NE, op2, c1, bbt, bbf,
                     eqrels);
      break;
    default:
      assert(0 && "only handle integer comparison");
      break;
    }
  }

  void applyCmpRegVal(llvm::CmpInst::Predicate p, llvm::Value *op1,
                      llvm::ConstantInt *c2, llvm::BasicBlock *bbt,
                      llvm::BasicBlock *bbf, EqRels &eqrels) {
    auto value2 = c2->getSExtValue();

    Interval ipredicateT;
    Interval ipredicateF;
    switch (p) {
    case llvm::CmpInst::Predicate::ICMP_SLT:
      ipredicateT = Interval(MIN, value2 - 1);
      ipredicateF = Interval(value2, MAX);
      break;
    case llvm::CmpInst::Predicate::ICMP_SLE:
      ipredicateT = Interval(MIN, value2);
      ipredicateF = Interval(value2 + 1, MAX);
      break;
    case llvm::CmpInst::Predicate::ICMP_SGT:
      ipredicateT = Interval(value2 + 1, MAX);
      ipredicateF = Interval(MIN, value2);
      break;
    case llvm::CmpInst::Predicate::ICMP_SGE:
      ipredicateT = Interval(value2, MAX);
      ipredicateF = Interval(MIN, value2 - 1);
      break;
    case llvm::CmpInst::Predicate::ICMP_EQ:
      ipredicateT = Interval(value2, value2);
      ipredicateF = Interval(MIN, MAX);
      break;
    case llvm::CmpInst::Predicate::ICMP_NE:
      ipredicateT = Interval(MIN, MAX);
      ipredicateF = Interval(value2, value2);
      break;
    default:
      assert(0 && "only cares about int comparison");
      break;
    }

    // merge the original interval of op1 and set its interval for the
    // successive bbs.
    assert(internalEnv.hasValue(op1));
    Interval i1 = internalEnv.lookup(op1);

    MY_KLEE_DEBUG(llvm::outs() << "setting envmap for t " << bbt << " as "
                               << (i1 & ipredicateT) << "\n");
    MY_KLEE_DEBUG(llvm::outs() << "setting envmap for f " << bbf << " as "
                               << (i1 & ipredicateF) << "\n");
    Env envT, envF;
    std::vector<Pointer> &vecP = eqrels.getRelatedPointers(op1);
    assert(vecP.size() == 1 &&
           "I have assumed there is only one pointer for a vreg");
    std::vector<VRegs> &vecV = eqrels.getRelatedVRegs(vecP.front());
    for (auto &&it : vecV) {
      envT.set(it, i1 & ipredicateT);
      envF.set(it, i1 & ipredicateF);
    }
    envT.set(vecP.front(), i1 & ipredicateT);
    envF.set(vecP.front(), i1 & ipredicateF);
    succEnvs.insert(std::make_pair(bbt, envT));
    succEnvs.insert(std::make_pair(bbf, envF));
  }

  // TODO
  void applyCmpRegReg(llvm::CmpInst::Predicate p, llvm::Value *op1,
                      llvm::Value *op2, llvm::BasicBlock *bbt,
                      llvm::BasicBlock *bbf, EqRels &eqrels) {

    auto valueLower = internalEnv.lookup(op2).getLower();
    auto valueUpper = internalEnv.lookup(op2).getUpper();

    Interval ipredicateT;
    Interval ipredicateF;
    switch (p) {
    case llvm::CmpInst::Predicate::ICMP_SLT:
      ipredicateT = Interval(MIN, valueLower - 1);
      ipredicateF = Interval(valueUpper, MAX);
      break;
    case llvm::CmpInst::Predicate::ICMP_SLE:
      ipredicateT = Interval(MIN, valueLower);
      ipredicateF = Interval(valueUpper + 1, MAX);
      break;
    case llvm::CmpInst::Predicate::ICMP_SGT:
      ipredicateT = Interval(valueUpper + 1, MAX);
      ipredicateF = Interval(MIN, valueLower);
      break;
    case llvm::CmpInst::Predicate::ICMP_SGE:
      ipredicateT = Interval(valueUpper, MAX);
      ipredicateF = Interval(MIN, valueLower - 1);
      break;
    case llvm::CmpInst::Predicate::ICMP_EQ:
      ipredicateT = Interval(valueLower, valueUpper);
      ipredicateF = Interval(MIN, MAX);
      break;
    case llvm::CmpInst::Predicate::ICMP_NE:
      ipredicateT = Interval(MIN, MAX);
      ipredicateF = Interval(valueLower, valueUpper);
      break;
    default:
      assert(0 && "only cares about int comparison\n");
    }

    assert(internalEnv.hasValue(op1));
    Interval i1 = internalEnv.lookup(op1);

    Env envT, envF;
    std::vector<Pointer> &vecP = eqrels.getRelatedPointers(op1);
    assert(vecP.size() == 1 &&
           "I have assumed there is only one pointer for a vreg");
    std::vector<VRegs> &vecV = eqrels.getRelatedVRegs(vecP.front());
    for (auto &&it : vecV) {
      envT.set(it, i1 & ipredicateT);
      envF.set(it, i1 & ipredicateF);
    }
    envT.set(vecP.front(), i1 & ipredicateT);
    envF.set(vecP.front(), i1 & ipredicateF);
    succEnvs.insert(std::make_pair(bbt, envT));
    succEnvs.insert(std::make_pair(bbf, envF));
  }

  void executeCallInst(llvm::CallInst *cinst) {
    llvm::Function *f = cinst->getCalledFunction();
    llvm::StringRef name = f->getName();
    if (name == "klee_make_symbolic") {
      llvm::Value *firstArg = cinst->getArgOperand(0);
      internalEnv.set(firstArg, Interval::Top());
    }

    if (cinst->getType()->isIntegerTy() || cinst->getType()->isPointerTy()) {
      internalEnv.set(cinst, Interval::Top());
    }
  }

  void executeOtherInst(llvm::Instruction *inst) {
    if (inst->getType()->isIntegerTy() || inst->getType()->isPointerTy()) {
      internalEnv.set(inst, Interval::Top());
    }
    MY_KLEE_DEBUG(llvm::outs() << "other llvm insts, ignoring\n");
  }
};
} // namespace klee

#endif
